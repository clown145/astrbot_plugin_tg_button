# 工作流 (Workflow) 功能详解

工作流是动态按钮插件 1.2.0 版本引入的核心功能，它提供了一个强大的可视化编排工具，允许您将多个独立的“动作”连接成一个复杂的、自动化的任务序列。

## 1. 什么是工作流？

您可以将工作流想象成一个流程图。在这个图中，每一个“节点”（Node）代表一个具体的操作（例如，发送一次 HTTP 请求、执行一段本地 Python 代码、或者调用一个模块动作），而连接节点的“边”（Edge）则定义了这些操作的执行顺序和数据流动方向。

当一个工作流被触发时，插件的执行引擎会像执行流程图一样，按照您定义的顺序和逻辑，一步步地完成所有节点的操作。

核心特性：

-   **可视化编排**：您可以在 WebUI 中通过拖拽的方式来创建和编辑工作流，非常直观。
-   **数据传递**：一个节点的输出（例如，从 API 获取的数据）可以作为后续节点的输入，实现了动作之间的数据共享和加工。
-   **逻辑复用**：创建好的工作流可以被任何按钮或菜单触发，实现了复杂逻辑的统一管理和复用。
-   **强大的扩展性**：工作流可以整合所有类型的动作，包括 HTTP 动作、本地动作以及新的模块化动作，扩展性极强。

## 2. 核心概念

-   **节点 (Node)**
    -   工作流中的基本执行单元。
    -   每个节点都绑定了一个具体的**动作 (Action)**。
    -   当工作流执行到该节点时，它所绑定的动作就会被执行。
    -   节点可以有多个输入端口和输出端口，用于接收和传递数据。

-   **边 (Edge)**
    -   连接两个节点的有向线段，定义了数据的流向和执行的依赖关系。
    -   一条边从源节点的**输出端口**连接到目标节点的**输入端口**。
    -   这意味着，源节点的某个输出值，将被用作目标节点的某个输入参数。
    -   **重要**：工作流是一个**有向无环图 (DAG)**，您不能创建循环依赖（例如，A→B→A），否则执行会失败。

-   **输入/输出 (Inputs/Outputs)**
    -   **输入**：一个动作执行时所需要的参数。在工作流中，这些参数的值可以被**写死**（在节点的设置面板中直接填写），也可以通过**边**从上游节点动态获取。
    -   **输出**：一个动作执行成功后产生的结果。这些结果可以被后续节点用作输入。

## 3. 工作原理

当一个工作流被触发时，`ActionExecutor` 会执行以下步骤：

1.  **加载定义**：从 `buttons_state.json` 文件中加载工作流的完整定义（所有节点和边）。
2.  **构建图并排序**：在内存中构建一个有向图，并使用**拓扑排序**算法（Kahn's Algorithm）来确定所有节点的正确执行顺序。这一步也会检测是否存在循环依赖。
3.  **顺序执行节点**：
    -   按照排好的顺序，依次执行每个节点所代表的动作。
    -   在执行一个节点前，它会先收集合适的输入参数：
        -   一部分可能是在 WebUI 中为该节点静态配置的。
        -   另一部分则根据“边”的定义，从已经执行完毕的上游节点的输出结果中获取。
    -   执行当前节点动作。
4.  **存储输出**：节点执行成功后，其输出变量会被记录下来，以供后续节点使用。
5.  **聚合结果**：
    -   工作流会将所有执行过的、且产生了 `new_text` 的节点的文本结果，用换行符连接起来，作为最终的返回消息。
    -   其他的 UI 效果（如跳转菜单、显示通知等）则以**最后一个**成功执行的节点的结果为准。

## 4. 如何创建和使用

目前，工作流的创建和编辑完全通过 **WebUI** 进行。

### 基本流程

1.  登录 WebUI。
2.  导航到“工作流”管理页面。
3.  点击“新建工作流”，进入可视化编辑器。
4.  从右侧的动作列表中，将您需要的动作拖拽到画布上，成为一个新的节点。
5.  拖动节点的输出端口（右侧）到另一个节点的输入端口（左侧），创建一条“边”，以实现数据传递。
6.  完成编排后，保存工作流。
7.  最后，在任何一个按钮或菜单的配置中，将其动作类型选为“工作流”，并指定您刚刚创建的工作流 ID 即可。

### 编辑器操作技巧

*   **编辑节点**：在画布上，**双击**任何一个节点，可以打开该节点的配置菜单，用于设置其绑定的动作和静态输入参数。
*   **删除节点或连接线**：在画布上，**右键点击**一个节点或一条连接线，会弹出一个×，选择“删除”即可将其移除。

## 5. 教程：创建一个简单的工作流

本教程将指导您创建一个最基本的工作流。目标是：**接收两个独立的文本，将它们拼接起来，并用拼接后的结果更新当前的菜单标题。**

### 准备工作

1.  进入 WebUI，导航到“工作流”页面，点击“新建工作流”。
2.  您会看到一个空白的画布。

### 步骤 1：添加输入节点

我们需要两个文本来源。这里我们使用 **`提供静态字符串`** 动作。

1.  从右侧动作列表中，找到并拖拽两个 **`提供静态字符串`** 节点到画布上。
2.  **双击**第一个节点，在配置面板的 `value` 字段中输入 `Hello, `。
3.  **双击**第二个节点，在 `value` 字段中输入 `World!`。

现在，您有了两个独立的节点，它们分别输出一个固定的字符串。

### 步骤 2：添加处理节点

接下来，我们需要一个节点来拼接这两个字符串。

1.  从右侧动作列表中，拖拽一个 **`拼接字符串`** 节点到画布上。
2.  将第一个 `提供静态字符串` 节点的输出端口（右侧圆点）拖拽连接到 `拼接字符串` 节点的 `string_a` 输入端口（左侧圆点）。
3.  同样地，将第二个 `提供静态字符串` 节点的输出端口连接到 `拼接字符串` 节点的 `string_b` 输入端口。

现在，`拼接字符串` 节点会接收前两个节点的输出作为输入。

### 步骤 3：添加输出节点

最后，我们需要将拼接的结果显示出来。

1.  从右侧动作列表中，拖拽一个 **`更新菜单标题`** 节点到画布上。
2.  将 `拼接字符串` 节点的 `result` 输出端口连接到 `更新菜单标题` 节点的 `text` 输入端口。

### 步骤 4：保存和使用

1.  点击右上角的“保存”，为您的工作流命名（例如 `simple_concat`）。
2.  进入“按钮”或“菜单”管理页面，创建一个新按钮。
3.  将按钮的动作类型设置为“工作流”，并在下方的下拉菜单中选择您刚刚创建的 `simple_concat` 工作流。
4.  保存所有更改。现在，当您在 Telegram 中点击这个按钮时，菜单的标题文本应该会更新为 "Hello, World!"。

这个简单的例子展示了工作流的核心思想：**将数据从一个节点的输出流向下游节点的输入，实现数据的加工和处理。**

## 6. 核心技巧与最佳实践

### 使用模板和占位符

许多动作（如 `发送新消息`）的输入参数支持 **Jinja2 模板**。这意味着您可以在参数中插入动态变量。

手动输入 `{{ runtime.chat_id }}` 这样的占位符既繁琐又容易出错。为了解决这个问题，我们提供了一个特殊的 **`提供占位符`** 动作。

**实践案例：发送一条包含用户ID的新消息**

1.  在工作流中添加一个 **`提供占位符`** 节点。它不需要任何输入。
2.  添加一个 **`发送新消息`** 节点。
3.  将 `提供占位符` 节点的 `chat_id_placeholder` 输出连接到 `发送新消息` 节点的 `chat_id` 输入。
4.  在 `发送新消息` 节点的 `text` 输入框中，**手动输入** `您的用户ID是: {{ runtime.user_id }}`。

**工作原理**：
*   `提供占位符` 节点本身只输出字符串 `{{ runtime.chat_id }}`。
*   当这个字符串被连接到 `发送新消息` 的 `chat_id` 输入时，工作流引擎会识别出这是一个模板，并在执行时将其**渲染**为真实的聊天 ID。
*   对于 `text` 字段，我们直接写入模板字符串，执行时同样会被渲染。

### 发送网络图片

`发送新消息` 动作的 `image_source` 参数需要的是**服务器本地的绝对文件路径**，它不能直接处理一个 URL。

正确的流程是：**下载 -> 缓存 -> 发送**。

**实践案例：下载并发送一张网络图片**

1.  **节点1: `从 URL 缓存文件`**
    *   将此节点添加到工作流。
    *   在其 `url` 输入中填入您想发送的图片的 URL (例如 `https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png`)。
2.  **节点2: `发送新消息`**
    *   添加此节点。
    *   将 `从 URL 缓存文件` 节点的 `file_path` 输出连接到 `发送新消息` 节点的 `image_source` 输入。
    *   记得连接 `chat_id`（可以来自 `提供占位符` 节点）。

**工作原理**：
`从 URL 缓存文件` 动作会下载该 URL 的内容，将其保存到服务器的一个临时文件中，然后将该文件的**绝对路径**作为输出。`发送新消息` 动作接收这个路径，读取文件内容，并将其发送给 Telegram。工作流执行完毕后，该临时文件会被自动清理。

### 控制执行顺序 (避免API调用超时)

假设您想连续发送两条消息。如果您将两个 `发送新消息` 节点都直接连接到起始节点，它们可能会被**并行执行**。在短时间内对 Telegram API 进行多次调用，可能会触发频率限制或导致超时错误。

使用 **`延迟/路由`** 节点来确保它们按顺序执行。

**实践案例：顺序发送两条消息**

1.  **节点1: `发送新消息` (消息A)**
    *   正常配置此节点。
2.  **节点2: `延迟/路由`**
    *   将 `发送新消息` (消息A) 节点的**任何一个输出** (例如 `message_id`) 连接到 `延迟/路由` 节点的 **`control_input` (控制流输入)**。
    *   `control_input` 的作用仅仅是建立一个执行依赖，它会“吞掉”传入的数据，不会向下游传递。
3.  **节点3: `发送新消息` (消息B)**
    *   将 `延迟/路由` 节点的 `passthrough_output` 连接到 `发送新消息` (消息B) 节点的**任何一个不重要的输入**上。由于 `passthrough_output` 此时为 `None`，这个连接也只是为了确立顺序。更稳妥的方式是直接将 `延迟/路由` 的输出连接到下一个 `延迟/路由` 节点，形成一个链条。
    *   **关键**：由于消息B的执行依赖于路由节点，而路由节点依赖于消息A，因此消息B一定会在消息A执行完毕后才会开始执行。

> **技巧**：如果您只是想建立顺序而不想引入延迟，只需将 `延迟/路由` 节点的 `delay_ms` 参数保持为 0 即可。

### 条件分支的最佳实践

在设计复杂的分支逻辑时，现在只需要在**分支入口节点**配置条件即可：当条件返回 `False` 时，该节点会被显式标记为“已跳过”，调度器也会同步跳过所有依赖它的下游节点，避免出现“缺少输入参数”的警告。下游节点会收到一个空的哨兵输出，因此它们不会被执行，也不会污染全局变量。这样可以将条件判断集中在入口节点，实现更清晰、易维护的分支结构。

为了更直观地复用条件判断，预设动作库新增了 **「条件判断 (Condition Check)」** 模块。它可以比较上游传入的数据（支持等于、不等、大小比较、包含、正则等），并输出布尔值以及其反向结果。通常的使用方式如下：

1.  在分支前插入一个「条件判断」节点，配置好比较逻辑，并为 `result_variable` 取一个易记的名字（例如 `should_notify`）。
2.  将该节点的 `result` 输出连接到下游节点任意一个暂不使用的输入端口，或者直接依赖它在全局变量中的别名。
3.  在下游节点的条件设置面板中，可以直接选择“来自上游连线”，从列表中勾选刚才连接的布尔端口；也可以继续使用“模板表达式”模式，点击提示区的一键填充按钮即可获得形如 `{{ inputs.should_notify }}` 的模板。若只依赖全局变量，则改写为 `{{ variables.should_notify }}` 即可。

保存后，调度器会自动识别 `inputs.*` 或 `variables.*` 中的布尔值，并根据结果决定是否执行当前节点。新的“来自上游连线”模式可以免去手写模板的步骤，并支持一键复制模板表达式，方便在其他节点中复用。

## 7. 预设动作详解

为了方便您快速构建工作流，插件内置了多个常用的模块化动作。

---

### `提供静态字符串`
*   **ID**: `provide_static_string`
*   **功能**: 在工作流中硬编码并提供一个字符串值。是构建动态文本的基础。
*   **输入**:
    *   `value` (string): 您想输出的静态字符串。
*   **输出**:
    *   `output` (string): 输入的 `value` 值原样输出。
*   **用例与说明**:
    *   **主要用途**: 此动作主要用于教学、测试和理解工作流的数据流。它提供了一个最简单的“数据源”。
    *   **实际使用**: 在实际构建复杂工作流时，如果一个文本值是固定的且只使用一次，直接在目标动作的输入框中填写通常更直接。但当**多个下游动作需要引用同一个固定的文本**时，使用此动作可以提供一个统一的数据源，便于统一修改和维护，让逻辑更清晰。

---

### `拼接字符串`
*   **ID**: `concat_strings`
*   **功能**: 将两个输入字符串连接成一个。
*   **输入**:
    *   `string_a` (string): 第一个字符串（前缀）。
    *   `string_b` (string): 第二个字符串（后缀）。
*   **输出**:
    *   `result` (string): `string_a` 和 `string_b` 拼接后的结果。
*   **用例与说明**:
    *   **主要用途**: 和 `提供静态字符串` 类似，这也是一个用于教学和演示的基础动作，清晰地展示了如何对数据进行“加工”。
    *   **实际使用**: 当需要将来自不同上游节点（如多个 API 响应、用户输入等）的文本片段组合成一段有意义的文本时，此动作非常有用。

---

### `条件判断 (Condition Check)`
*   **ID**: `branch_condition`
*   **功能**: 读取上游节点或静态填写的两个值进行比较，输出布尔结果和其反向值，可作为工作流分支的判定入口。
*   **输入**:
    *   `left` (any): 左值，可以通过连接线或静态参数提供。
*   `operator` (string): 通过下拉框选择比较运算符（带中文提示），支持 `equals`、`not_equals`、`greater`、`less_or_equal`、`contains`、`matches` 等常见写法。
    *   `right` (any): 右值，部分运算符（如 `is_truthy`）可以留空。
    *   `case_insensitive` (boolean): 是否忽略大小写。
    *   `interpret_numbers` (boolean): 是否在比较前尝试将字符串转换为数字。
    *   `result_variable` (string): 可选的全局变量别名，写入后可在条件模板里通过 `{{ variables.别名 }}` 使用。
*   **输出**:
    *   `result` (boolean): 判断结果。
    *   `negated_result` (boolean): 结果取反后的布尔值，方便直接驱动“反向分支”。
    *   `result_as_text` (string): 结果的文本形式（`"true"` 或 `"false"`）。
*   **用法提示**:
    *   将 `result` 输出连接到目标节点未使用的输入端口，可在节点条件中通过 `{{ inputs.端口名 }}` 读取。
    *   若只想引用全局变量，可设置 `result_variable`，无需额外连接线，直接写 `{{ variables.别名 }}` 即可。
    *   条件配置面板会自动识别来自「条件判断」的布尔输出，并在“模板表达式”模式下提供快速填充按钮，避免手动输入表达式；即便多个分支共享同一个上游数据节点，也只会执行与布尔结果匹配的分支。

---

### `按钮重定向 (Redirect Trigger Button)`
*   **ID**: `redirect_trigger_button`
*   **功能**: 把当前触发工作流的按钮临时变成另一个既有按钮，复用其回调逻辑和交互体验，可用于“跳转”到其他菜单、动作或工作流。
*   **输入**:
    *   `target_button_id` (button): 选择要复用的目标按钮。前端会列出所有现有按钮并显示其所属菜单与 ID，便于快速定位。
    *   `reuse_target_text` (boolean): 是否同步目标按钮的文案，默认为 `True`。
    *   `custom_text` (string): 可选的自定义文案；填写后会覆盖上面的同步逻辑，方便在重定向时提示用户。
*   **输出**: 无。
*   **用法提示**:
    *   适合在“引导流程”中动态改写当前按钮，让下一次点击直接执行另一个按钮绑定的动作/工作流，无需复制配置。
    *   如果只想临时跳转到某个菜单，直接选择对应的“子菜单”按钮即可；动作或工作流同理。
    *   也可以在条件节点后使用：当满足特定条件时把按钮导向不同的目标，实现“按钮级别”的分支体验。

---

### `等待用户输入 (Await User Input)`
*   **ID**: `await_user_input`
*   **功能**: 向当前触发工作流的用户发送一段提示语，并暂停执行直至收到其下一条文本消息。用户回复的文本会作为输出提供给后续节点，同时可选地存入全局变量。
*   **输入**:
    *   `prompt` (string): 提示用户输入时发送的消息内容。
    *   `timeout` (integer): 最大等待时长，单位秒，超时后可发送提醒。
    *   `allow_empty` (boolean): 是否接受空白输入；若禁用可配合 `retry_prompt` 再次提醒。
    *   `retry_prompt` (string): 在不允许空白输入时，用户发送空消息后显示的提示文字。
    *   `timeout_message` (string): 等待超时时发送给用户的消息，留空则静默结束。
    *   `delete_prompt` (boolean): 收到有效输入后是否删除提示消息，默认为否。
    *   `acknowledge_template` (string): 收到输入后发送的确认消息，支持 `{{ user_input }}` 占位符回显用户内容。
    *   `store_variable` (string): 可选的全局变量名；填写后会把用户输入写入该变量，便于后续节点通过 `{{ variables.变量名 }}` 读取。
*   **输出**:
    *   `user_text` (string): 用户刚刚发送的文本内容。
    *   `timed_out` (boolean): 是否因为超时而未获取到输入。
    *   `prompt_message_id` (integer): 提示消息的 ID（若成功发送）。
    *   `response_message_id` (integer): 用户回复消息的 ID（若可获取）。
*   **用法提示**:
    *   将 `user_text` 输出连接到下游节点的输入端口，即可把用户回复作为后续动作的参数。
    *   配合条件节点可以根据 `timed_out` 或自定义变量判断是否继续执行分支逻辑。
    *   可与“模板表达式”或“来自上游连线”条件搭配，实现“询问-判断-执行”的完整交互流程。

---

### `更新菜单标题`
*   **ID**: `update_message`
*   **功能**: 用新的文本内容更新当前菜单的标题文本（即按钮上方显示的提示文字）。
*   **输入**:
    *   `text` (string): 要显示的新的菜单标题。
*   **输出**: 无。
*   **用例**: 在工作流执行完毕后，将最终结果动态展示在菜单标题上，实现动态反馈。

---

### `提供占位符`
*   **ID**: `provide_placeholders`
*   **功能**: 这是一个辅助动作，它不执行计算，而是提供一组常用的 Jinja2 模板占位符。这使得您可以在 WebUI 中通过拖拽连接的方式，轻松地将运行时变量（如用户ID、聊天ID）传递给其他动作，而无需手动输入 `{{ ... }}`。
*   **输入**: 无。
*   **输出**:
    *   `chat_id_placeholder` (string): 输出 `{{ runtime.chat_id }}`
    *   `user_id_placeholder` (string): 输出 `{{ runtime.user_id }}`
    *   ... (其他所有占位符)
*   **用例**: 连接到 `发送新消息` 的 `chat_id` 输入，或在 HTTP 请求的参数中使用 `{{ runtime.user_id }}`。

---

### `发送新消息`
*   **ID**: `send_message`
*   **功能**: 向指定聊天窗口发送一条全新的消息，可以包含文本、图片或语音。
*   **输入**:
    *   `chat_id` (string): 目标聊天的 ID。**必须提供**，通常来自 `提供占位符`。
    *   `text` (string): 消息文本或媒体文件的说明文字。
    *   `image_source` (string): **本地图片文件路径**。必须与 `从 URL 缓存文件` 配合使用来发送网络图片。
    *   `voice_source` (string): **本地语音文件路径**。
*   **输出**:
    *   `message_id` (integer): 新发送消息的唯一 ID，可用于后续操作（如编辑或删除）。
*   **用例**: 在工作流中主动向用户推送通知、发送处理结果或图片。

---

### `从 URL 缓存文件`
*   **ID**: `cache_from_url`
*   **功能**: 从给定的 URL 下载文件，将其保存在服务器的临时目录中，并返回其本地绝对路径。
*   **输入**:
    *   `url` (string): 要下载的文件的公开 URL。
    *   `filename` (string, 可选): 保存文件时使用的名称。如果省略，会自动生成。
*   **输出**:
    *   `file_path` (string): 文件在服务器上的绝对路径。
*   **用例**: **发送网络图片的唯一正确方法**。先用此动作下载图片，然后将其 `file_path` 输出连接到 `发送新消息` 的 `image_source` 输入。

---

### `显示弹窗通知`
*   **ID**: `show_notification`
*   **功能**: 在用户的 Telegram 客户端顶部显示一个短暂的通知或一个需要确认的警报框。
*   **输入**:
    *   `text` (string): 通知内容。
    *   `show_alert` (boolean): `true` 表示为警报框，`false` 表示为普通通知。
*   **输出**: 无。
*   **用例**: 给予用户非阻塞性的即时反馈，例如 "操作已成功" 或 "正在处理中..."。

---

### `延迟/路由`
*   **ID**: `delay`
*   **功能**: 这是一个多用途的控制流工具。
    1.  **延迟**: 在工作流中暂停指定的毫秒数。
    2.  **路由/排序**: 建立节点间的执行顺序依赖，而不传递任何数据。
*   **输入**:
    *   `delay_ms` (integer): 需要延迟的毫秒数。
    *   `control_input` (any): **控制流输入**。此端口接收到的任何数据都会被“吞掉”，仅用于确立执行依赖。
    *   `passthrough_input` (any): **数据流输入**。此端口接收到的数据会在延迟后，从 `passthrough_output` 原样输出。
*   **输出**:
    *   `passthrough_output` (any): 将从 `passthrough_input` 接收到的数据原样输出。
*   **用例**:
    *   在连续调用 API 之间插入短暂延迟，避免触发频率限制。
    *   强制两个或多个 `发送新消息` 动作按顺序执行，而不是并行执行。

---

### `编辑消息文本`
*   **ID**: `edit_message_text`
*   **功能**: 更新一条已存在的**纯文本**消息的内容。如果目标消息包含媒体，此动作会失败。
*   **输入**:
    *   `chat_id` (string): 消息所在的聊天 ID。
    *   `message_id` (integer): 要编辑的消息的唯一 ID。
    *   `text` (string): 新的文本内容。
*   **输出**:
    *   `message_id` (integer): 成功编辑后返回的消息 ID。
*   **用例**: 在发送一条纯文本消息后，动态更新其内容，例如更新状态或显示计算结果。

---

### `编辑媒体消息`
*   **ID**: `edit_message_media`
*   **功能**: 更新一条已存在的**带媒体**消息的图片/语音，和/或它的说明文字 (caption)。
*   **输入**:
    *   `chat_id` (string): 消息所在的聊天 ID。
    *   `message_id` (integer): 要编辑的消息的唯一 ID。
    *   `text` (string, 可选): 新的说明文字。如果只提供此项，则只更新说明文字。
    *   `image_source` (string, 可选): 要替换的**本地图片文件路径**。
    *   `voice_source` (string, 可选): 要替换的**本地语音文件路径**。
*   **输出**:
    *   `message_id` (integer): 成功编辑后返回的消息 ID。
*   **用例**: 发送一张“加载中”的占位图片，在任务完成后，将其替换为真正的结果图片，并更新说明文字。

---

### `删除消息`
*   **ID**: `delete_message`
*   **功能**: 根据 `chat_id` 和 `message_id` 删除一条指定的消息。
*   **输入**:
    *   `chat_id` (string): 消息所在的聊天 ID。
    *   `message_id` (integer): 要删除的消息的唯一 ID。
*   **输出**: 无。
*   **用例**:
    *   **实现“阅后即焚”**: 在用户查看消息后，通过延迟然后删除的方式，自动清理消息。
    *   **清理临时消息**: 在工作流执行过程中，可能会发送一些临时的状态消息（如“正在处理中...”），在任务完成后，可以使用此动作将其删除，保持聊天界面的整洁。

## 8. 高级教程：实现“阅后即焚”图片

这个教程将向您展示如何结合多个动作，创建一个“阅后即焚”的效果：发送一张图片，它会在几秒钟后自动更新提示文本，并最终被删除。

### 节点准备

您需要在工作流中准备以下节点：
*   `从 URL 缓存文件` (1个)
*   `发送新消息` (1个)
*   `延迟/路由` (2个)
*   `编辑媒体消息` (1个)
*   `删除消息` (1个)
*   `提供占位符` (1个，用于提供 chat_id)

### 步骤 1：缓存并发送初始图片

1.  **节点1: `从 URL 缓存文件`**: 在 `url` 输入中填入您想发送的图片 URL。
2.  **节点2: `提供占位符`**: 用于提供运行时变量。
3.  **节点3: `发送新消息`**:
    *   将其 `text` 输入设置为 `"这张图片将在 4 秒后自动销毁..."`。
    *   连接 `从 URL 缓存文件` 的 `file_path` 输出到 `发送新消息` 的 `image_source` 输入。
    *   连接 `提供占位符` 的 `chat_id_placeholder` 输出到 `发送新消息` 的 `chat_id` 输入。

此时，工作流会下载图片并将其附带一条说明文字发送出去。关键在于 `发送新消息` 会输出一个 `message_id`，这是我们后续所有操作的目标。

### 步骤 2：第一次延迟与更新文本

1.  **节点4: `延迟/路由`**:
    *   将其 `delay_ms` 设置为 `2000` (2秒)。
    *   连接 `发送新消息` 的 `message_id` 输出到 `延迟/路由` 的 `passthrough_input` 输入。这一步既传递了 `message_id`，也建立了执行依赖。
2.  **节点5: `编辑媒体消息`**:
    *   将其 `text` 输入设置为 `"还有 2 秒..."`。
    *   连接 `延迟/路由` 的 `passthrough_output` 输出到 `编辑媒体消息` 的 `message_id` 输入。
    *   同样，连接 `提供占位符` 的 `chat_id_placeholder` 到此节点的 `chat_id` 输入。

现在，在消息发送 2 秒后，它的说明文字会被自动更新。

### 步骤 3：第二次延迟与删除消息

1.  **节点6: `延迟/路由` (第二个)**:
    *   将其 `delay_ms` 设置为 `2000` (2秒)。
    *   连接 `编辑媒体消息` 的 `message_id` 输出到第二个 `延迟/路由` 节点的 `passthrough_input` 输入。
2.  **节点7: `删除消息`**:
    *   连接第二个 `延迟/路由` 节点的 `passthrough_output` 输出到 `删除消息` 的 `message_id` 输入。
    *   再次从 `提供占位符` 节点的 `chat_id_placeholder` 输出连接到此节点的 `chat_id` 输入。

工作流的最后一步，是在第二次延迟后，彻底删除这条消息。

### 流程总结

这个工作流巧妙地利用了 `延迟/路由` 节点的 `passthrough` 功能来**传递 `message_id`**，同时利用其 `delay_ms` 功能来**控制时间**，最终通过 `编辑媒体消息` 和 `删除消息` 动作来完成对特定消息的生命周期管理。
